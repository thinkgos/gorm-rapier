<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gorm Rapier Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="resources/prism.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gorm Rapier Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/thinkgos/gorm-rapier" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rapier-guides"><a class="header" href="#rapier-guides">rapier Guides</a></h1>
<ul>
<li><a href="00-overview.html#rapier-guides">rapier Guides</a>
<ul>
<li><a href="00-overview.html#overview">Overview</a></li>
<li><a href="00-overview.html#installation">Installation</a></li>
</ul>
</li>
</ul>
<p><a href="https://github.com/thinkgos/gorm-rapier">gorm-rapier</a> is an assist rapier for gorm.</p>
<p><a href="https://pkg.go.dev/github.com/thinkgos/gorm-rapier?tab=doc"><img src="https://img.shields.io/badge/go.dev-reference-blue?logo=go&amp;logoColor=white" alt="Go.Dev reference" /></a>
<a href="https://codecov.io/gh/thinkgos/gorm-rapier"><img src="https://codecov.io/gh/thinkgos/gorm-rapier/graph/badge.svg?token=aHu5wq1m6i" alt="codecov" /></a>
<a href="https://github.com/thinkgos/gorm-rapier/actions/workflows/ci.yml"><img src="https://github.com/thinkgos/gorm-rapier/actions/workflows/ci.yml/badge.svg?branch=main" alt="Tests" /></a>
<a href="https://goreportcard.com/report/github.com/thinkgos/gorm-rapier"><img src="https://goreportcard.com/badge/github.com/thinkgos/gorm-rapier" alt="Go Report Card" /></a>
<a href="https://raw.githubusercontent.com/thinkgos/gorm-rapier/main/LICENSE"><img src="https://img.shields.io/github/license/thinkgos/gorm-rapier" alt="Licence" /></a>
<a href="https://github.com/thinkgos/gorm-rapier/tags"><img src="https://img.shields.io/github/v/tag/thinkgos/gorm-rapier" alt="Tag" /></a></p>
<ul>
<li><a href="http://gorm.io/docs">gorm Guides</a></li>
<li><a href="https://thinkgos.github.io/gorm-rapier/">gorm rapier Guides</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<ul>
<li>Idiomatic and Reusable API from Dynamic Raw SQL</li>
<li>100% Type-safe API without interface{}</li>
<li>Almost supports all features, plugins, DBMS that GORM supports</li>
<li>Almost same behavior as gorm you used.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Use go get.</p>
<pre><code class="language-bash">go get github.com/thinkgos/gorm-rapier
</code></pre>
<p>Then import the package into your own code.</p>
<pre><code class="language-go">import "github.com/thinkgos/gorm-rapier"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-models"><a class="header" href="#declaring-models">Declaring Models</a></h1>
<ul>
<li><a href="01-declaring-models.html#declaring-models">Declaring Models</a>
<ul>
<li><a href="01-declaring-models.html#declaring-gorm-model">Declaring gorm model</a></li>
<li><a href="01-declaring-models.html#declaring-rapier-model">Declaring rapier model</a></li>
<li><a href="01-declaring-models.html#how-to-define-model">How to define model</a></li>
</ul>
</li>
</ul>
<h2 id="declaring-gorm-model"><a class="header" href="#declaring-gorm-model">Declaring gorm model</a></h2>
<p><a href="https://gorm.io/docs/models.html">Declaring gorm Models</a></p>
<h2 id="declaring-rapier-model"><a class="header" href="#declaring-rapier-model">Declaring rapier model</a></h2>
<p>Supported field:</p>
<ul>
<li>bool: <code>Bool</code></li>
<li>[]byte: <code>Bytes</code></li>
<li>float: <code>Float32</code>, <code>Float64</code>, <code>Decimal</code></li>
<li>integer: <code>Int</code>, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>
<li>unsigned integer: <code>Uint</code>, <code>Uint8</code>, <code>Uint16</code>, <code>Uint32</code>, <code>Uint64</code></li>
<li>string: <code>String</code></li>
<li>time.Time: <code>Time</code></li>
<li>any: <code>Field</code></li>
<li>raw filed: <code>Raw</code></li>
</ul>
<h2 id="how-to-define-model"><a class="header" href="#how-to-define-model">How to define model</a></h2>
<p>model defined for test <a href="https://github.com/thinkgos/gorm-rapier/tree/main/testdata">testdata</a>.</p>
<p>if we have a gorm model follow:</p>
<pre><code class="language-go">// Dict 字典
type Dict struct {
    Id        int64     `gorm:"column:id;autoIncrement:true;not null;primaryKey" json:"id,omitempty"`
    Key       string    `gorm:"column:key;type:varchar(64);not null;default:'';uniqueIndex:uk_key" json:"key,omitempty"`
    Name      string    `gorm:"column:name;type:varchar(64);not null;default:''" json:"name,omitempty"`
    IsPin     bool      `gorm:"column:is_pin;type:tinyint(1);not null;default:0" json:"is_pin,omitempty"`
    Remark    string    `gorm:"column:remark;type:varchar(128);not null;default:''" json:"remark,omitempty"`
    CreatedAt time.Time `gorm:"column:created_at;type:datetime;not null" json:"created_at,omitempty"`
    UpdatedAt time.Time `gorm:"column:updated_at;type:datetime;not null" json:"updated_at,omitempty"`
}

// TableName implement schema.Tabler interface
func (*Dict) TableName() string {
    return "dict"
}
</code></pre>
<p>then we can define rapier model:</p>
<pre><code class="language-go">var ref_Dict_Native = New_Dict("dict")

type Dict_Native struct {
    refAlias     string
    refTableName string
    ALL          rapier.Asterisk
    Id           rapier.Int64
    Key          rapier.String
    Name         rapier.String
    IsPin        rapier.Bool
    Remark       rapier.String
    CreatedAt    rapier.Time
    UpdatedAt    rapier.Time
}

func new_Dict(tableName, alias string) *Dict_Native {
    return &amp;Dict_Native{
        refAlias:     alias,
        refTableName: tableName,
        ALL:          rapier.NewAsterisk(alias),
        Id:           rapier.NewInt64(alias, "id"),
        Key:          rapier.NewString(alias, "key"),
        Name:         rapier.NewString(alias, "name"),
        IsPin:        rapier.NewBool(alias, "is_pin"),
        Remark:       rapier.NewString(alias, "remark"),
        CreatedAt:    rapier.NewTime(alias, "created_at"),
        UpdatedAt:    rapier.NewTime(alias, "updated_at"),
    }
}

// Ref_Dict model with TableName `dict`.
func Ref_Dict() *Dict_Native { return ref_Dict_Native }

// New_Dict new instance.
func New_Dict(tableName string) *Dict_Native {
    return new_Dict(tableName, tableName)
}

// As alias
func (x *Dict_Native) As(alias string) *Dict_Native {
    return new_Dict(x.refTableName, alias)
}

// Alias hold alias name when call Dict_Active.As that you defined.
func (x *Dict_Native) Alias() string { return x.refAlias }

// TableName hold table name when call New_Dict that you defined.
func (x *Dict_Native) TableName() string { return x.refTableName }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-a-database"><a class="header" href="#connecting-to-a-database">Connecting to a Database</a></h1>
<p><a href="https://gorm.io/docs/connecting_to_the_database.html">Connecting to a Database</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crud-interface"><a class="header" href="#crud-interface">CRUD interface</a></h1>
<p><code>Executor[T]</code>'s <code>Where</code>, <code>Or</code>, <code>Not</code>, <code>Having</code> and the suffix with <code>Expr</code> method can use field which implement <code>Expr</code> interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create">Create</a></h1>
<ul>
<li><a href="03-crud/01-create.html#create">Create</a>
<ul>
<li><a href="03-crud/01-create.html#empty-record">Empty record</a></li>
<li><a href="03-crud/01-create.html#single-record">Single record</a></li>
<li><a href="03-crud/01-create.html#multiple-record">Multiple record</a></li>
<li><a href="03-crud/01-create.html#batch-insert-multiple-record">Batch insert multiple record</a></li>
</ul>
</li>
</ul>
<h2 id="empty-record"><a class="header" href="#empty-record">Empty record</a></h2>
<pre><code class="language-go">// empty record
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).Create()
_ = err          // return error
_ = rowsAffected // return row affected
</code></pre>
<h2 id="single-record"><a class="header" href="#single-record">Single record</a></h2>
<pre><code class="language-go">// single record
newDict := testdata.Dict{
    Key:    "key1",
    Name:   "name1",
    IsPin:  true,
    Remark: "remark1",
}
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).Create(&amp;newDict)
_ = err          // return error
_ = rowsAffected // return row affected
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("key1","name1",true,"remark1","2024-02-20 07:18:42.135","2024-02-20 07:18:42.135")
</code></pre>
<h2 id="multiple-record"><a class="header" href="#multiple-record">Multiple record</a></h2>
<pre><code class="language-go">// multiple record
newDicts := []*testdata.Dict{
    {
        Key:    "key1",
        Name:   "name1",
        IsPin:  true,
        Remark: "remark1",
    },
    {
        Key:    "key2",
        Name:   "name2",
        IsPin:  true,
        Remark: "remark2",
    },
}
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).Create(newDicts...)
_ = err          // return error
_ = rowsAffected // return row affected
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("key1","name1",true,"remark1","2024-02-20 07:18:42.136","2024-02-20 07:18:42.136"),("key2","name2",true,"remark2","2024-02-20 07:18:42.136","2024-02-20 07:18:42.136")
</code></pre>
<h2 id="batch-insert-multiple-record"><a class="header" href="#batch-insert-multiple-record">Batch insert multiple record</a></h2>
<pre><code class="language-go">// batch insert multiple record
newDicts := []*testdata.Dict{
    {
        Key:    "key1",
        Name:   "name1",
        IsPin:  true,
        Remark: "remark1",
    },
    {
        Key:    "key2",
        Name:   "name2",
        IsPin:  true,
        Remark: "remark2",
    },
    {
        Key:    "key3",
        Name:   "name3",
        IsPin:  true,
        Remark: "remark3",
    },
}
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).CreateInBatches(newDicts, 2)
_ = err          // return error
_ = rowsAffected // return row affected
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("key1","name1",true,"remark1","2024-02-20 07:18:42.136","2024-02-20 07:18:42.136"),("key2","name2",true,"remark2","2024-02-20 07:18:42.136","2024-02-20 07:18:42.136")
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("key3","name3",true,"remark3","2024-02-20 07:18:42.135","2024-02-20 07:18:42.135")
</code></pre>
<p>more information <a href="https://gorm.io/docs/create.html">gorm Create</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">Query</a></h1>
<ul>
<li><a href="03-crud/02-query.html#query">Query</a>
<ul>
<li><a href="03-crud/02-query.html#retrieving-a-single-object">Retrieving a single object</a></li>
<li><a href="03-crud/02-query.html#retrieving-a-single-field">Retrieving a single field</a></li>
<li><a href="03-crud/02-query.html#retrieving-multiple-objects">Retrieving multiple objects</a></li>
<li><a href="03-crud/02-query.html#condition">Condition</a></li>
<li><a href="03-crud/02-query.html#selecting-specific-fields">Selecting Specific Fields</a></li>
<li><a href="03-crud/02-query.html#order">Order</a></li>
<li><a href="03-crud/02-query.html#limit--offset">Limit &amp; Offset</a></li>
<li><a href="03-crud/02-query.html#group-by--having">Group By &amp; Having</a></li>
<li><a href="03-crud/02-query.html#distinct">Distinct</a></li>
<li><a href="03-crud/02-query.html#joins">Joins</a></li>
<li><a href="03-crud/02-query.html#scan">Scan</a></li>
</ul>
</li>
</ul>
<h2 id="retrieving-a-single-object"><a class="header" href="#retrieving-a-single-object">Retrieving a single object</a></h2>
<pre><code class="language-go">var record2 testdata.Dict

// Get the first record ordered by primary key
record1, err := rapier.NewExecutor[testdata.Dict](db).FirstOne()
_ = err     // return error
_ = record1 // return record
// Get one record, no specified order
record1, err = rapier.NewExecutor[testdata.Dict](db).TakeOne()
_ = err     // return error
_ = record1 // return record
// Get one record, no specified order
record1, err = rapier.NewExecutor[testdata.Dict](db).LastOne()
_ = err     // return error
_ = record1 // return record

// Get the first record ordered by primary key  with original gorm api
err = rapier.NewExecutor[testdata.Dict](db).First(&amp;record2)
_ = err     // return error
_ = record2 // return record
// Get one record, no specified order with original gorm api
err = rapier.NewExecutor[testdata.Dict](db).Take(&amp;record2)
_ = err     // return error
_ = record2 // return record
// Get one record, no specified order with original gorm api
err = rapier.NewExecutor[testdata.Dict](db).Last(&amp;record2)
_ = err     // return error
_ = record2 // return record
</code></pre>
<h2 id="retrieving-a-single-field"><a class="header" href="#retrieving-a-single-field">Retrieving a single field</a></h2>
<p>the api like <code>FirstXXX</code> or <code>TakeXXX</code>, return follow type: <code>bool</code>,<code>string</code>, <code>float32</code>, <code>float64</code>, <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// Get the first record ordered returned single field.
_ = err // return error
_, err = rapier.NewExecutor[testdata.Dict](db).SelectExpr(refDict.Key).FirstString()
// SELECT `dict`.`key` FROM `dict` ORDER BY `dict`.`id` LIMIT 1

// Get one record, no specified order returned single field.
_, err = rapier.NewExecutor[testdata.Dict](db).SelectExpr(refDict.Key).TakeString()
// SELECT `dict`.`key` FROM `dict` LIMIT 1
</code></pre>
<h2 id="retrieving-multiple-objects"><a class="header" href="#retrieving-multiple-objects">Retrieving multiple objects</a></h2>
<pre><code class="language-go">// Get the multiple record.
records1, err := rapier.NewExecutor[testdata.Dict](db).
    FindAll()
_ = err      // return error
_ = records1 // return records
// SELECT * FROM `dict`

var records2 []*testdata.Dict
// Get the multiple record.
err = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(rapier.All).
    Find(&amp;records2)
_ = err      // return error
_ = records1 // return records
// SELECT * FROM `dict`
</code></pre>
<h2 id="condition"><a class="header" href="#condition">Condition</a></h2>
<p>In addition to <a href="https://gorm.io/docs/query.html#Conditions">gorm Conditions</a> usages, there are usable usage related to <code>rapier</code></p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()

// =
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Eq("key1")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` = "key1" LIMIT 1
// &lt;&gt;
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Neq("key1")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` &lt;&gt; "key1" LIMIT 1
// IN
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.In("key1", "key2")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` IN ("key1","key2") LIMIT 1
// NOT IN
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.NotIn("key1", "key2")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` NOT IN ("key1","key2") LIMIT 1
// Fuzzy LIKE
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.FuzzyLike("key1")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` LIKE "%key1%" LIMIT 1
// Left LIKE
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.LeftLike("key1")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` LIKE "key1%" LIMIT 1
// LIKE
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Like("%key1%")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` LIKE "%key1%" LIMIT 1
// NOT LIKE
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.NotLike("%key1%")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` NOT LIKE "%key1%" LIMIT 1
// AND
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Eq("key1"), refDict.IsPin.Eq(true)).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` = "key1" AND `dict`.`is_pin` = true LIMIT 1
// &gt;
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.Gt(time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`created_at` &gt; "2024-03-07 06:20:47.057" LIMIT 1
// &gt;=
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.Gte(time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`created_at` &gt;= "2024-03-07 06:20:47.057" LIMIT 1
// &lt;
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.Lt(time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`created_at` &lt; "2024-03-07 06:20:47.057" LIMIT 1
// &lt;=
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.Lte(time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`created_at` &lt;= "2024-03-07 06:20:47.057" LIMIT 1
// BETWEEN
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.Between(time.Now().Add(time.Hour), time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`created_at` BETWEEN "2024-03-07 07:20:47.057" AND "2024-03-07 06:20:47.057" LIMIT 1
// NOT BETWEEN
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.CreatedAt.NotBetween(time.Now().Add(time.Hour), time.Now())).TakeOne()
// SELECT * FROM `dict` WHERE NOT (`dict`.`created_at` BETWEEN "2024-03-07 07:20:47.057" AND "2024-03-07 06:20:47.057") LIMIT 1
 
// not condition
_, _ = rapier.NewExecutor[testdata.Dict](db).Not(refDict.Key.Eq("key1")).TakeOne()
// SELECT * FROM `dict` WHERE NOT `dict`.`key` = "key1" LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(rapier.Not(refDict.Key.Eq("key1"))).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` &lt;&gt; "key1" LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Not(refDict.Key.In("key1", "key2")).TakeOne()
// SELECT * FROM `dict` WHERE NOT `dict`.`key` IN ("key1","key2") LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(rapier.Not(refDict.Key.In("key1", "key2"))).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` NOT IN ("key1","key2") LIMIT 1

// Or condition
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Eq("key1")).Or(refDict.Key.Eq("key2")).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` = "key1" OR `dict`.`key` = "key2" LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(rapier.Or(refDict.Key.Eq("key1"), refDict.Key.Eq("key2"))).TakeOne()
// SELECT * FROM `dict` WHERE (`dict`.`key` = "key1" OR `dict`.`key` = "key2") LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(refDict.Key.Eq("key1")).Or(refDict.Key.Eq("key2"), refDict.IsPin.Eq(true)).TakeOne()
// SELECT * FROM `dict` WHERE `dict`.`key` = "key1" OR (`dict`.`key` = "key2" AND `dict`.`is_pin` = true) LIMIT 1
_, _ = rapier.NewExecutor[testdata.Dict](db).Where(rapier.Or(refDict.Key.Eq("key1"), rapier.And(refDict.Key.Eq("key2"), refDict.IsPin.Eq(true)))).TakeOne()
// SELECT * FROM `dict` WHERE (`dict`.`key` = "key1" OR (`dict`.`key` = "key2" AND `dict`.`is_pin` = true))
</code></pre>
<h2 id="selecting-specific-fields"><a class="header" href="#selecting-specific-fields">Selecting Specific Fields</a></h2>
<p><code>Select</code>, <code>SelectExpr</code> allows you to specify the fields that you want to retrieve from database.</p>
<pre><code class="language-go">var records []*struct {
    Key   string
    IsPin bool
}
refDict := testdata.Ref_Dict()

// with expr
_ = rapier.NewExecutor[testdata.Dict](db).SelectExpr(refDict.Key, refDict.IsPin).Find(&amp;records)
// SELECT `dict`.`key`,`dict`.`is_pin` FROM `dict`
_ = rapier.NewExecutor[testdata.Dict](db).SelectExpr(refDict.Key.Trim("1").As(refDict.Key.ColumnName()), refDict.IsPin).Find(&amp;records)
// SELECT TRIM(BOTH "1" FROM `dict`.`key`) AS `key`,`dict`.`is_pin` FROM `dict`

// with original gorm api
_ = rapier.NewExecutor[testdata.Dict](db).Select("key", "is_pin").Find(&amp;records)
// SELECT `key`,`is_pin` FROM `dict`
</code></pre>
<h2 id="order"><a class="header" href="#order">Order</a></h2>
<p>Specify order when retrieving records from the database</p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()

// with expr
_, _ = rapier.NewExecutor[testdata.Dict](db).OrderExpr(refDict.Key.Desc(), refDict.Name).FindAll()
// SELECT * FROM `dict` ORDER BY `dict`.`key` DESC,`dict`.`name`
_, _ = rapier.NewExecutor[testdata.Dict](db).OrderExpr(refDict.Key.Desc()).OrderExpr(refDict.Name).FindAll()
// SELECT * FROM `dict` ORDER BY `dict`.`key` DESC,`dict`.`name`

// with original gorm api
_, _ = rapier.NewExecutor[testdata.Dict](db).Order("`key` DESC,name").FindAll()
// SELECT * FROM `dict` ORDER BY `key` DESC,name
_, _ = rapier.NewExecutor[testdata.Dict](db).Order("`key` DESC").Order("name").FindAll()
// SELECT * FROM `dict` ORDER BY `key` DESC,name
</code></pre>
<h2 id="limit--offset"><a class="header" href="#limit--offset">Limit &amp; Offset</a></h2>
<p><code>Pagination</code>:</p>
<ul>
<li><code>page</code>: page index</li>
<li><code>perPage</code>: per page size (default size is 50, default max size is 500)</li>
<li><code>maxPerPages</code>: override default max size.</li>
</ul>
<p><code>Limit</code>: specify the max number of records to retrieve.<br />
<code>Offset</code>: specify the number of records to skip before starting to return the records</p>
<pre><code class="language-go">// with Pagination
_, _ = rapier.NewExecutor[testdata.Dict](db).Pagination(3, 5).FindAll()
// SELECT * FROM `dict` LIMIT 5 OFFSET 10

// with original gorm api
_, _ = rapier.NewExecutor[testdata.Dict](db).Limit(3).FindAll()
// SELECT * FROM `dict` LIMIT 3
_, _ = rapier.NewExecutor[testdata.Dict](db).Offset(3).FindAll()
// SELECT * FROM `dict` OFFSET 3
_, _ = rapier.NewExecutor[testdata.Dict](db).Limit(10).Offset(5).FindAll()
// SELECT * FROM `dict` LIMIT 10 OFFSET 5
</code></pre>
<h2 id="group-by--having"><a class="header" href="#group-by--having">Group By &amp; Having</a></h2>
<pre><code class="language-go">var result struct {
    Name  string
    Total int
}

refDict := testdata.Ref_Dict()
// with expr
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Name,
        rapier.Star.Count().As("total"),
    ).
    Where(refDict.Name.LeftLike("group")).
    GroupExpr(refDict.Name).
    Take(&amp;result)
// SELECT `dict`.`name`,COUNT(*) AS `total` FROM `dict` WHERE `dict`.`name` LIKE "group%" GROUP BY `dict`.`name`

_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Name,
        rapier.Star.Count().As("total"),
    ).
    GroupExpr(refDict.Name).
    Having(refDict.Name.Eq("group")).
    Take(&amp;result)
// SELECT `dict`.`name`,COUNT(*) AS `total` FROM `dict` GROUP BY `dict`.`name` HAVING `dict`.`name` = "group"

// with original gorm api
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Name,
        rapier.Star.Count().As("total"),
    ).
    Where(refDict.Name.LeftLike("group")).
    Group("name").
    Take(&amp;result)
// SELECT `dict`.`name`,COUNT(*) AS `total` FROM `dict` WHERE `dict`.`name` LIKE "group%" GROUP BY `name` LIMIT 1

_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Name,
        rapier.Star.Count().As("total"),
    ).
    Group("name").
    Having("name = ?", "group").
    Take(&amp;result)
// SELECT `dict`.`name`,COUNT(*) AS `total` FROM `dict` GROUP BY `name` HAVING name = "group" LIMIT 1
</code></pre>
<h2 id="distinct"><a class="header" href="#distinct">Distinct</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// with expr
_, _ = rapier.NewExecutor[testdata.Dict](db).
    DistinctExpr(
        refDict.Name,
        refDict.IsPin,
    ).
    FindAll()
// SELECT DISTINCT `dict`.`name`,`dict`.`is_pin` FROM `dict`

// with original gorm api
_, _ = rapier.NewExecutor[testdata.Dict](db).
    Distinct("name", "is_pin").
    FindAll()
// SELECT DISTINCT `name`,`is_pin` FROM `dict`
</code></pre>
<h2 id="joins"><a class="header" href="#joins">Joins</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
refDictItem := testdata.Ref_DictItem()
d := refDict.As("d")
di := refDictItem.As("di")

// join
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Id.As(refDict.Id.FieldName(refDict.TableName())),
        refDict.Key.As(refDict.Key.FieldName(refDict.TableName())),
        refDictItem.Name.As(refDictItem.Name.FieldName(refDictItem.TableName())),
    ).
    InnerJoinsExpr(refDictItem, refDictItem.DictId.EqCol(refDict.Id), refDictItem.IsEnabled.Eq(true)).
    Take(&amp;struct{}{})
// SELECT `dict`.`id` AS `dict_id`,`dict`.`key` AS `dict_key`,`dict_item`.`name` AS `dict_item_name` FROM `dict` INNER JOIN `dict_item` ON `dict_item`.`dict_id` = `dict`.`id` AND `dict_item`.`is_enabled` = true LIMIT 1

// join with alias
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Id.As(refDict.Id.FieldName(refDict.TableName())),
        refDict.Key.As(refDict.Key.FieldName(refDict.TableName())),
        d.Id.As(d.Id.FieldName(d.Alias())),
    ).
    InnerJoinsExpr(rapier.NewJoinTable(d, d.Alias()), d.Name.EqCol(refDict.Name), d.IsPin.Eq(true)).
    Take(&amp;struct{}{})
// SELECT `dict`.`id` AS `dict_id`,`dict`.`key` AS `dict_key`,`d`.`id` AS `d_id` FROM `dict` INNER JOIN `dict` `d` ON `d`.`name` = `dict`.`name` AND `d`.`is_pin` = true LIMIT 1

// join with alias which table implements Alias interface.
// we can directly use it. no need `NewJoinTable`.
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Id.As(refDict.Id.FieldName(refDict.TableName())),
        refDict.Key.As(refDict.Key.FieldName(refDict.TableName())),
        d.Id.As(d.Id.FieldName(d.Alias())),
    ).
    InnerJoinsExpr(d, d.Name.EqCol(refDict.Name), d.IsPin.Eq(true)).
    Take(&amp;struct{}{})
// SELECT `dict`.`id` AS `dict_id`,`dict`.`key` AS `dict_key`,`d`.`id` AS `d_id` FROM `dict` INNER JOIN `dict` `d` ON `d`.`name` = `dict`.`name` AND `d`.`is_pin` = true LIMIT 1

// join with SubQuery
_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Id.As(refDict.Id.FieldName(refDict.TableName())),
        refDict.Key.As(refDict.Key.FieldName(refDict.TableName())),
        di.Sort.As(di.Sort.FieldName(di.Alias())),
    ).
    InnerJoinsExpr(
        rapier.NewJoinTableSubQuery(
            rapier.NewExecutor[testdata.DictItem](db).
                Where(refDictItem.IsEnabled.Eq(true)).
                IntoDB(),
            "di",
        ),
        di.Name.EqCol(refDict.Name),
        di.Sort.Gt(10),
    ).
    Take(&amp;struct{}{})
// SELECT `dict`.`id` AS `dict_id`,`dict`.`key` AS `dict_key`,`di`.`sort` AS `di_sort` FROM `dict` INNER JOIN (SELECT * FROM `dict_item` WHERE `dict_item`.`is_enabled` = true) AS `di` ON `di`.`name` = `dict`.`name` AND `di`.`sort` &gt; 10 LIMIT 1
</code></pre>
<h2 id="scan"><a class="header" href="#scan">Scan</a></h2>
<p>Retrieving a single field, the api like <code>ScanXXX</code> return follow type: <code>bool</code>,<code>string</code>, <code>float32</code>, <code>float64</code>, <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>.</p>
<pre><code class="language-go">var record2 testdata.Dict

// Get one record, no specified order
record1, err := rapier.NewExecutor[testdata.Dict](db).ScanOne()
_ = err     // return error
_ = record1 // return record
// SELECT * FROM `dict`
// Get one record, no specified order with original gorm api
err = rapier.NewExecutor[testdata.Dict](db).Scan(&amp;record2)
_ = err     // return error
_ = record2 // return record
// SELECT * FROM `dict`
</code></pre>
<p>more information <a href="https://gorm.io/docs/query.html">gorm Query</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-query"><a class="header" href="#advanced-query">Advanced Query</a></h1>
<ul>
<li><a href="03-crud/03-advanced-query.html#advanced-query">Advanced Query</a>
<ul>
<li><a href="03-crud/03-advanced-query.html#locking">Locking</a></li>
<li><a href="03-crud/03-advanced-query.html#subquery">SubQuery</a></li>
<li><a href="03-crud/03-advanced-query.html#from-subquery">From SubQuery</a></li>
<li><a href="03-crud/03-advanced-query.html#in-with-multiple-columns">IN with multiple columns</a></li>
<li><a href="03-crud/03-advanced-query.html#firstorinit">FirstOrInit</a></li>
<li><a href="03-crud/03-advanced-query.html#firstorcreate">FirstOrCreate</a></li>
<li><a href="03-crud/03-advanced-query.html#pluck">Pluck</a></li>
<li><a href="03-crud/03-advanced-query.html#count">Count</a></li>
<li><a href="03-crud/03-advanced-query.html#exist">Exist</a></li>
<li><a href="03-crud/03-advanced-query.html#function">Function</a>
<ul>
<li><a href="03-crud/03-advanced-query.html#case-when">Case When</a></li>
<li><a href="03-crud/03-advanced-query.html#concat">Concat</a></li>
<li><a href="03-crud/03-advanced-query.html#if">IF</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>more information <a href="https://gorm.io/docs/advanced_query.html">gorm Advanced Query</a></p>
<h2 id="locking"><a class="header" href="#locking">Locking</a></h2>
<pre><code class="language-go">// Basic FOR UPDATE lock
_, _ = rapier.NewExecutor[testdata.Dict](db).
    LockingUpdate().
    TakeOne()
// SELECT * FROM `dict` LIMIT 1 FOR UPDATE
// Basic FOR UPDATE lock with Clauses api
_, _ = rapier.NewExecutor[testdata.Dict](db).
    Clauses(clause.Locking{Strength: "UPDATE"}).
    TakeOne()
// SELECT * FROM `dict` LIMIT 1 FOR UPDATE

// Basic FOR SHARE lock
_, _ = rapier.NewExecutor[testdata.Dict](db).
    LockingShare().
    TakeOne()
// SELECT * FROM `dict` LIMIT 1 FOR SHARE
// Basic FOR SHARE lock with Clauses api
_, _ = rapier.NewExecutor[testdata.Dict](db).
    Clauses(clause.Locking{Strength: "SHARE"}).
    TakeOne()
// SELECT * FROM `dict` LIMIT 1 FOR SHARE

// Basic FOR UPDATE NOWAIT lock with Clauses api
_, _ = rapier.NewExecutor[testdata.Dict](db).
    Clauses(clause.Locking{Strength: "UPDATE",Options: "NOWAIT"}).
    TakeOne()
// SELECT * FROM `dict` LIMIT 1 FOR UPDATE NOWAIT
</code></pre>
<h2 id="subquery"><a class="header" href="#subquery">SubQuery</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()

_ = rapier.NewExecutor[testdata.Dict](db).
    SelectExpr(
        refDict.Id,
        refDict.Key,
        rapier.NewExecutor[testdata.Dict](db).
            SelectExpr(rapier.Star.Count()).
            Where(
                refDict.Name.Eq("kkk"),
            ).
            IntoSubQueryExpr().As("total"),
    ).
    Where(refDict.Key.LeftLike("key")).
    Find(&amp;struct{}{})
// SELECT `dict`.`id`,`dict`.`key`,(SELECT COUNT(*) FROM `dict` WHERE `dict`.`name` = "kkk") AS `total` FROM `dict` WHERE `dict`.`key` LIKE "key%"

_, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(refDict.Key.EqSubQuery(
        rapier.NewExecutor[testdata.Dict](db).
            SelectExpr(refDict.Key).
            Where(refDict.Id.Eq(1001)).
            IntoDB(),
    )).
    FindAll()
// SELECT * FROM `dict` WHERE `dict`.`key` = (SELECT `dict`.`key` FROM `dict` WHERE `dict`.`id` = 1001)
</code></pre>
<h2 id="from-subquery"><a class="header" href="#from-subquery">From SubQuery</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
_, _ = rapier.NewExecutor[testdata.Dict](db).
    TableExpr(
        rapier.From{
            Alias: "u",
            SubQuery: rapier.NewExecutor[testdata.Dict](db).
                SelectExpr(refDict.Key).
                IntoDB(),
        },
        rapier.From{
            Alias: "p",
            SubQuery: rapier.NewExecutor[testdata.Dict](db).
                SelectExpr(refDict.Key).
                IntoDB(),
        },
    ).
    FindAll()
// SELECT * FROM (SELECT `dict`.`key` FROM `dict`) AS `u`, (SELECT `dict`.`key` FROM `dict`) AS `p`
</code></pre>
<h2 id="in-with-multiple-columns"><a class="header" href="#in-with-multiple-columns">IN with multiple columns</a></h2>
<p>supports the IN clause with multiple columns, allowing you to filter data based on multiple field values in a single query.</p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()

record1, _ := rapier.NewExecutor[testdata.Dict](db).
    Where(
        rapier.NewColumns(refDict.Name, refDict.IsPin).
            In([][]any{{"name1", true}, {"name2", false}}),
    ).
    FindAll()
_ = record1
// SELECT * FROM `dict` WHERE (`dict`.`name`, `dict`.`is_pin`) IN (("name1",true),("name2",false))
record2, _ := rapier.NewExecutor[testdata.Dict](db).
    Where(
        rapier.NewColumns(refDict.Name, refDict.IsPin).
            In(
                rapier.NewExecutor[testdata.Dict](db).
                    SelectExpr(refDict.Name, refDict.IsPin).
                    Where(refDict.Id.In(10, 11)).
                    IntoDB(),
            ),
    ).
    FindAll()
_ = record2
// SELECT * FROM `dict` WHERE (`dict`.`name`,`dict`.`is_pin`) IN (SELECT `dict`.`name`,`dict`.`is_pin` FROM `dict` WHERE `dict`.`id` IN (10,11))
</code></pre>
<h2 id="firstorinit"><a class="header" href="#firstorinit">FirstOrInit</a></h2>
<p><code>FirstOrInit</code> method is utilized to fetch the first record that matches given conditions, or initialize a new instance if no matching record is found. This method allows additional flexibility with the <code>Attrs</code>, <code>Assign</code>, <code>AttrsExpr</code>, <code>AssignExpr</code> methods.</p>
<ul>
<li><code>Attrs</code>, <code>AttrsExpr</code>: When no record is found, you can use <code>Attrs</code>,<code>AttrsExpr</code> to initialize a struct with additional attributes. These attributes are included in the new struct but are not used in the SQL query.</li>
<li><code>Assign</code>, <code>AssignExpr</code> method allows you to set attributes on the struct regardless of whether the record is found or not. These attributes are set on the struct but are not used to build the SQL query and the final data won’t be saved into the database.</li>
</ul>
<p><em><strong>NOTE!!!</strong></em>: if with expr condition will not initialize the field when initializing, so we should use <code>Attrs</code>, <code>AttrsExpr</code>, <code>Assign</code>, <code>AssignExpr</code> attributes to indicate these fields.</p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// NOTE!!!: if with expr condition will not initialize the field when initializing, so we should use
// `Attrs`, `AttrsExpr`, `Assign`, `AssignExpr` attributes to indicate these fields.

// `Attrs`, `AttrsExpr`
// with expr
result, _ := rapier.NewExecutor[testdata.Dict](db).
    Where(refDict.Name.Eq("myname")).
    AttrsExpr(refDict.Remark.Value("remark11")).
    FirstOrInit()
newdict := result.Data
rowsAffected := result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Condition use expr. here will not initialize the field of the condition when initializing.
// if not found
// newdict -&gt; Dict{ Remark: "remark11" }
//
// if found, `Attrs`, `AttrsExpr` are ignored
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark" }

// with original gorm api
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(&amp;testdata.Dict{
        Name: "non_existing",
    }).
    FirstOrInit()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Condition not use expr, here will initialize the field of the condition when initializing.
// newdict -&gt; Dict{ Name: "non_existing" } if not found
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(&amp;testdata.Dict{
        Name: "myname",
    }).
    Attrs(&amp;testdata.Dict{Remark: "remark11"}).
    FirstOrInit()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Condition not use expr, here will initialize the field of the condition when initializing.
// if not found
// newdict -&gt; Dict{ Name: "myname", Remark: "remark11" }
//
// if found, `Attrs`, `AttrsExpr` are ignored
// newdict -&gt; Dict{ Id: 1, Name: "myname", Remark: "remark" }

// `Assign`, `AssignExpr`
// with expr
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(refDict.Name.Eq("myname")).
    AssignExpr(refDict.Remark.Value("remark11")).
    FirstOrInit()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Where condition use expr, here will not initialize the field of the condition when initializing.
//  if not found
// newdict -&gt; Dict{ Remark: "remark11" }
//
//  if not found
// newdict -&gt; Dict{ Name: "non_existing" }
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(&amp;testdata.Dict{
        Name: "myname",
    }).
    Assign(&amp;testdata.Dict{Remark: "remark11"}).
    FirstOrInit()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: condition not use expr, here will initialize the field of the condition when initializing.
// if not found
// newdict -&gt; Dict{ Name: "myname", Remark: "remark11" }
//
// if found, `Assign`, `AssignExpr` are set on the struct
// newdict -&gt; Dict{ Id: 1, Name: "myname", Remark: "remark11" }
</code></pre>
<h2 id="firstorcreate"><a class="header" href="#firstorcreate">FirstOrCreate</a></h2>
<p><code>FirstOrCreate</code> is used to fetch the first record that matches given conditions or create a new one if no matching record is found. This method is effective with both struct and map conditions. The RowsAffected property is useful to determine the number of records created or updated.</p>
<ul>
<li><code>Attrs</code>, <code>AttrsExpr</code> can be used to specify additional attributes for the new record if it is not found. These attributes are used for creation but not in the initial search query.</li>
<li><code>Assign</code>, <code>AssignExpr</code> method sets attributes on the record regardless of whether it is found or not, and these attributes are saved back to the database.</li>
</ul>
<p><em><strong>NOTE!!!</strong></em>: if with expr condition will not initialize the field when creating, so we should use
<code>Attrs</code>, <code>AttrsExpr</code>, <code>Assign</code>, <code>AssignExpr</code> attributes to indicate these fields.</p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// NOTE!!!: if with expr condition will not initialize the field when creating, so we should use
// `Attrs`, `AttrsExpr`, `Assign`, `AssignExpr` attributes to indicate these fields.

// `Attrs`, `AttrsExpr`
// with expr
result, _ := rapier.NewExecutor[testdata.Dict](db).
    Where(refDict.Name.Eq("myname")).
    AttrsExpr(refDict.Remark.Value("remark11")).
    FirstOrCreate()
newdict := result.Data
rowsAffected := result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Condition use expr. here will not initialize the field of the condition when creating.
// if not found. initialize with additional attributes
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1;
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("","",false,"remark11","2024-03-08 02:20:10.853","2024-03-08 02:20:10.853");
// newdict -&gt; Dict{ Id: 11, Name: "", Remark: "remark11" } if not found
//
// if found, `Attrs`, `AttrsExpr` are ignored.
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark" }

// with original gorm api
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(&amp;testdata.Dict{
        Name: "myname",
    }).
    Attrs(&amp;testdata.Dict{Remark: "remark11"}).
    FirstOrCreate()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Condition not use expr, here will initialize the field of the condition when creating.
// if not found, initialize with given conditions and additional attributes
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1;
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("","myname",false,"remark11","2024-03-08 02:20:10.853","2024-03-08 02:20:10.853");
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark11" }
//
// if found, `Attrs`, `AttrsExpr` are ignored
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark" }

// `Assign`, `AssignExpr`
// with expr
result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(refDict.Name.Eq("myname")).
    AssignExpr(refDict.Remark.Value("remark11")).
    FirstOrCreate()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: Where condition use expr, here will not initialize the field of the condition when creating.
// whether it is found or not, and `Assign`, `AssignExpr` attributes are saved back to the database.
// if no found
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("","",false,"remark11","2024-03-08 02:26:12.619","2024-03-08 02:26:12.619");
// newdict -&gt; Dict{ Id: 11, Name: "", Remark: "remark11", ... }
//
// if found
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1
// UPDATE `dict` SET `remark` = "remark11" WHERE id = "11"
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark11", ... }

result, _ = rapier.NewExecutor[testdata.Dict](db).
    Where(&amp;testdata.Dict{
        Name: "myname",
    }).
    Assign(&amp;testdata.Dict{Remark: "remark11"}).
    FirstOrCreate()
newdict = result.Data
rowsAffected = result.RowsAffected
_ = newdict
_ = rowsAffected
// NOTE: condition not use expr, here will initialize the field of the condition when creating.
// whether it is found or not, and `Assign`, `AssignExpr` attributes are saved back to the database.
// if no found
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1
// INSERT INTO `dict` (`key`,`name`,`is_pin`,`remark`,`created_at`,`updated_at`) VALUES ("","myname",false,"remark11","2024-03-08 02:26:12.619","2024-03-08 02:26:12.619");
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark11", ... }
//
// if found
// SELECT * FROM `dict` WHERE `dict`.`name` = "myname" ORDER BY `dict`.`id` LIMIT 1
// UPDATE `dict` SET `remark` = "remark11" WHERE id = "11"
// newdict -&gt; Dict{ Id: 11, Name: "myname", Remark: "remark11", ... }
</code></pre>
<h2 id="pluck"><a class="header" href="#pluck">Pluck</a></h2>
<p>The <code>Pluck</code>, <code>PluckExpr</code> method is used to query a single column from the database and scan the result into a slice. This method is ideal for when you need to retrieve specific fields from a model.</p>
<p>If you need to query more than one column, you can use Select with <code>Scan</code> or <code>Find</code> instead.</p>
<pre><code class="language-go">var ids []int64

refDict := testdata.Ref_Dict()
// with expr api
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprString(refDict.Name)
// SELECT `name` FROM `dict`
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprBool(refDict.IsPin)
// SELECT `is_pin` FROM `dict`
_ = rapier.NewExecutor[testdata.Dict](db).Pluck("id", &amp;ids)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprInt(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprInt8(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprInt16(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprInt32(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprInt64(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprUint(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprUint8(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprUint16(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprUint32(refDict.Id)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckExprUint64(refDict.Id)
// SELECT `id` FROM `dict`

// with original gorm api
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckString("name")
// SELECT `name` FROM `dict`
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckBool("is_pin")
// SELECT `is_pin` FROM `dict`
_ = rapier.NewExecutor[testdata.Dict](db).Pluck("id", &amp;ids)
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckInt("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckInt8("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckInt16("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckInt32("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckInt64("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckUint("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckUint8("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckUint16("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckUint32("id")
_, _ = rapier.NewExecutor[testdata.Dict](db).PluckUint64("id")
// SELECT `id` FROM `dict`
</code></pre>
<h2 id="count"><a class="header" href="#count">Count</a></h2>
<p>The <code>Count</code> method is used to retrieve the number of records that match a given query. It’s a useful feature for understanding the size of a dataset, particularly in scenarios involving conditional queries or data analysis.</p>
<pre><code class="language-go">total, err := rapier.NewExecutor[testdata.Dict](db).Count()
_ = err
_ = total
// SELECT count(*) FROM `dict`
</code></pre>
<h2 id="exist"><a class="header" href="#exist">Exist</a></h2>
<p>The <code>Exist</code> method is used to check whether the exist record that match a given query.</p>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
b, err := rapier.NewExecutor[testdata.Dict](db).Where(refDict.Id.Eq(100)).Exist()
_ = err
_ = b
// SELECT 1 FROM `dict` WHERE `dict`.`id` = 100 LIMIT 1
</code></pre>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<h3 id="case-when"><a class="header" href="#case-when">Case When</a></h3>
<pre><code class="language-go">NewCaseWhen().
WhenThen(NewField("", "id1").Gt(100), NewField("", "value1")).
WhenThen(NewField("", "id2").Gt(200), NewField("", "value2")).
Else(NewField("", "result")).
Build()
// (CASE WHEN `id1` &gt; ? THEN `value1` WHEN `id2` &gt; ? THEN `value2` ELSE `result` END)
</code></pre>
<h3 id="concat"><a class="header" href="#concat">Concat</a></h3>
<pre><code class="language-go">ConcatCol(NewString("", "id"), NewString("", "new_id"), NewString("", "new_id2"))
// CONCAT(`id`,`new_id`,`new_id2`)

ConcatWsCol(NewRaw(`'-'`), NewString("", "id"), NewString("", "new_id"), NewString("", "new_id2"))
// CONCAT_WS('-',`id`,`new_id`,`new_id2`)
</code></pre>
<h3 id="if"><a class="header" href="#if">IF</a></h3>
<pre><code class="language-go">IF(NewField("", "id1").Gt(100), NewRaw("t"), NewField("", "f").Sub(1))
// IF(`id1` &gt; ?,t,`f`-?)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update"><a class="header" href="#update">Update</a></h1>
<ul>
<li><a href="03-crud/04-update.html#update">Update</a>
<ul>
<li><a href="03-crud/04-update.html#save-will-save-all-fields"><code>Save</code> will save all fields</a></li>
<li><a href="03-crud/04-update.html#update-single-column">Update single column</a></li>
<li><a href="03-crud/04-update.html#updates-multiple-columns">Updates multiple columns</a></li>
<li><a href="03-crud/04-update.html#update-from-subquery">Update from SubQuery</a></li>
<li><a href="03-crud/04-update.html#without-hookstime-tracking">Without Hooks/Time Tracking</a></li>
</ul>
</li>
</ul>
<h2 id="save-will-save-all-fields"><a class="header" href="#save-will-save-all-fields"><code>Save</code> will save all fields</a></h2>
<p><code>Save</code> will save all fields when performing the Updating SQL</p>
<pre><code class="language-go">rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
    Model().
    Save(&amp;testdata.Dict{
        Id:     100,
        Key:    "k1",
        Remark: "remark1",
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`name`="",`is_pin`=false,`remark`="remark1",`created_at`="2024-03-07 01:53:14.633",`updated_at`="2024-03-07 01:53:14.633" WHERE `id` = 100
</code></pre>
<h2 id="update-single-column"><a class="header" href="#update-single-column">Update single column</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// update with expr
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateExpr(refDict.Key, "k1")
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`updated_at`="2024-03-07 02:10:44.258" WHERE `dict`.`id` = 100

// update AssignExpr with expr
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateExpr(refDict.UpdatedAt, refDict.CreatedAt.Add(time.Second))
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `updated_at`=DATE_ADD(`dict`.`created_at`, INTERVAL 1000000 MICROSECOND) WHERE `dict`.`id`

// update with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    Update("key", "k1")
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`updated_at`="2024-03-07 02:10:44.258" WHERE `dict`.`id` = 100
</code></pre>
<h2 id="updates-multiple-columns"><a class="header" href="#updates-multiple-columns">Updates multiple columns</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// update with expr
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdatesExpr(
        refDict.Key.Value("k1"),
        refDict.Remark.Value(""),
    )
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`remark`="",`updated_at`="2024-03-07 02:19:10.144" WHERE `dict`.`id` = 100

// update use `struct` with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    Updates(&amp;testdata.Dict{
        Key:    "k1",
        Remark: "remark1",
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`remark`="remark1",`updated_at`="2024-03-07 02:19:10.144" WHERE `dict`.`id` = 100

// update use map with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdatesMap(map[string]any{
        "key":    "k1",
        "remark": "remark1",
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`remark`="remark1",`updated_at`="2024-03-07 02:19:10.144" WHERE `dict`.`id` = 100
</code></pre>
<h2 id="update-from-subquery"><a class="header" href="#update-from-subquery">Update from SubQuery</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// update with expr
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateExpr(
        refDict.Key,
        rapier.NewExecutor[testdata.Dict](db).Model().
            SelectExpr(refDict.Key).
            Where(refDict.Id.Eq(101)).
            IntoDB(),
    )
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`=(SELECT `dict`.`key` FROM `dict` WHERE `dict`.`id` = 101),`updated_at`="2024-03-07 02:41:40.548" WHERE `dict`.`id` = 100

// update with exprs
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdatesExpr(
        refDict.Key.ValueSubQuery(
            rapier.NewExecutor[testdata.Dict](db).Model().
                SelectExpr(refDict.Key).
                Where(refDict.Id.Eq(101)).
                IntoDB(),
        ),
    )
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`=(SELECT `dict`.`key` FROM `dict` WHERE `dict`.`id` = 101),`updated_at`="2024-03-07 02:41:40.548" WHERE `dict`.`id` = 100

// update use map with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdatesMap(map[string]any{
        "key": rapier.NewExecutor[testdata.Dict](db).Model().
            SelectExpr(refDict.Key).
            Where(refDict.Id.Eq(101)).
            IntoDB(),
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`=(SELECT `dict`.`key` FROM `dict` WHERE `dict`.`id` = 101),`updated_at`="2024-03-07 02:41:40.548" WHERE `dict`.`id` = 100
</code></pre>
<h2 id="without-hookstime-tracking"><a class="header" href="#without-hookstime-tracking">Without Hooks/Time Tracking</a></h2>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
// update with expr
rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateColumnsExpr(
        refDict.Key.Value("k1"),
        refDict.Remark.Value(""),
    )
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1",`remark`="" WHERE `dict`.`id` = 100

// update with expr
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateColumnExpr(refDict.Key, "k1")
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1" WHERE `dict`.`id` = 100

// update with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateColumn("key", "k1")
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1" WHERE `dict`.`id` = 100

// update with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateColumns(&amp;testdata.Dict{
        Key: "k1",
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1" WHERE `dict`.`id` = 100

// update with original gorm api
rowsAffected, err = rapier.NewExecutor[testdata.Dict](db).
    Model().
    Where(refDict.Id.Eq(100)).
    UpdateColumnsMap(map[string]any{
        "key": "k1",
    })
_ = err          // return error
_ = rowsAffected // return row affected
// UPDATE `dict` SET `key`="k1" WHERE `dict`.`id` = 100
</code></pre>
<p>more information <a href="https://gorm.io/docs/update.html">gorm Update</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete"><a class="header" href="#delete">Delete</a></h1>
<pre><code class="language-go">refDict := testdata.Ref_Dict()
    rowsAffected, err := rapier.NewExecutor[testdata.Dict](db).
        Model().
        Where(refDict.Id.Eq(100)).
        Delete()
    _ = err          // return error
    _ = rowsAffected // return row affected
 // DELETE FROM `dict` WHERE `dict`.`id` = 100
</code></pre>
<p>more information <a href="https://gorm.io/docs/delete.html">gorm Delete</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-sql--sql-builder"><a class="header" href="#raw-sql--sql-builder">Raw SQL &amp; SQL Builder</a></h1>
<p><a href="https://gorm.io/docs/sql_builder.html">Raw SQL &amp; SQL Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="original-gorm-db"><a class="header" href="#original-gorm-db">Original gorm db</a></h1>
<p><code>IntoDB</code>, <code>IntoRawDB</code> will get original gorm db.</p>
<ul>
<li><code>IntoDB</code>: with model or table</li>
<li><code>IntoRawDB</code>: without model or table</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<p><a href="https://gorm.io/docs/transactions.html">gorm transaction</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associations"><a class="header" href="#associations">Associations</a></h1>
<p>not supported yet, you can use <a href="https://gorm.io/docs/">gorm original api</a>'s associations topic.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="resources/prism.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
